<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fly ID & iNat Queue Workspace</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="modal-location" class="modal">
    <div class="modal-content">
        <h3>Change Search Location</h3>

<div style="position:relative; margin-bottom: 15px;">
        <input type="text" id="location-search-input" placeholder="Search for a place (e.g. California)..." oninput="searchPlaces(this.value)" autocomplete="off">
        <div id="location-results-dropdown" style="position:absolute; width:100%; background:white; border:1px solid #ccc; max-height:200px; overflow-y:auto; z-index:100; display:none; box-shadow: 0 4px 6px rgba(0,0,0,0.1);"></div>
    </div>

        <p style="font-size: 0.8rem; color: #666;">Or enter a comma-separated list of iNaturalist Place IDs (e.g., 6712,1 for USA & Canada). You can also enter other filters *after* the locality, e.g. "6712,1&user_id=edanko".</p>
        <input type="text" id="new-place-id" placeholder="e.g. 6712,1">
        <div style="display:flex; gap:10px;">
            <button onclick="updateLocation()" class="btn-id" style="cursor: pointer; flex:1; padding:10px;">Update & Refresh</button>
            <button onclick="closeModals()" class="btn-skip" style="cursor: pointer; flex:1; padding:10px;">Cancel</button>
        </div>
    </div>
</div>

<div id="modal-id" class="modal">
    <div class="modal-content">
        <h3>Add Identification</h3>

        <div id="suggested-id-area" style="margin-bottom: 15px; padding: 10px; background: #eef9ff; border: 1px dashed #2980b9; border-radius: 4px; font-size: 0.9rem; display: none;">
            <strong>Matrix Suggestion:</strong> <span id="suggestion-text"></span>
        </div>

<div style="position:relative; margin-bottom: 15px;">
            <input type="text" id="taxon-search-input" placeholder="Start typing taxon name (e.g. Lucilia)..." oninput="searchTaxa(this.value)" autocomplete="off">
            <div id="search-results-dropdown" style="position:absolute; width:100%; background:white; border:1px solid #ccc; max-height:200px; overflow-y:auto; z-index:100; display:none; box-shadow: 0 4px 6px rgba(0,0,0,0.1);"></div>
        </div>

        <input type="number" id="manual-taxon-id" placeholder="Enter Taxon ID Number...">
        <div style="display:flex; gap:10px;">
            <button onclick="submitManualID()" class="btn-id" style="cursor: pointer; flex:1; padding:10px; border:none; border-radius:4px;">Submit</button>
            <button onclick="closeModals()" class="btn-skip" style="cursor: pointer; flex:1; padding:10px; border:none; border-radius:4px;">Cancel</button>
        </div>
    </div>
</div>

<div id="modal-comment" class="modal">
    <div class="modal-content">
        <h3>Add Comment</h3>
        <textarea id="comment-body" rows="4" placeholder="Type your comment..."></textarea>
        <div style="display:flex; gap:10px;">
            <button onclick="submitComment()" class="btn-action" style="cursor: pointer; flex:1; padding:10px; border:none; border-radius:4px;">Post Comment</button>
            <button onclick="closeModals()" class="btn-skip" style="cursor: pointer; flex:1; padding:10px; border:none; border-radius:4px;">Cancel</button>
        </div>
    </div>
</div>

<div id="token-bar">
    <div>
        <span id="token-status"></span>
			<button id="change-loc-btn" onclick="openLocationModal()" class="btn-toggle" style="margin-left: 10px; font-size: 0.7rem;">Change Location</button>
        <span id="queue-count" style="font-size: 0.8em; opacity: 0.8;"></span>
    </div>

    <div class="token-section-center">
        Interactive field-character key to <i>Lucilia</i> of the USA and Canada
    </div>

<button id="toggle-viewer-btn" onclick="toggleViewerPanel()" class="btn-toggle">Hide iNat interface</button>


    <div id="token-controls" class="hidden">
        <a href="https://www.inaturalist.org/users/api_token" target="_blank" class="token-link">Get Token</a>
        <input type="text" id="token-input" placeholder="Paste api_token...">
        <button onclick="updateTokenManual()" style="background:var(--inat-green); color:white; border:none; padding:5px 10px; border-radius:4px; cursor:pointer;">Save</button>
    </div>
</div>

<div class="workspace-grid">
    <div class="viewer-panel">
        <div id="observation-grid">
            <div style="text-align:center; padding: 50px; color: #666;">Waiting for token/data...</div>
        </div>
    </div>

    <div class="matrix-container">
        <div class="matrix-panel">
            <div class="question-menu" id="question-menu"></div>
            <div class="identification-area">
                <div class="active-question-section" id="active-question-area">
                    <div style="color:#999; text-align:center; padding-top:50px;">Select a trait to begin identification.</div>
                </div>
                <div class="summary-box">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0;">Diagnostic Narrative</h4>
<button id="copy-narrative-btn" onclick="copyNarrativeToClipboard()" style="padding: 4px 8px; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background: #f8f9fa; font-size: 0.7rem;">Copy to Clipboard</button>
                    </div>
                    <p id="summary-content" style="font-size: 0.9rem; margin:0;">Select traits to generate description.</p>
                </div>
                <div class="results-sidebar">
                    <h4 style="margin:0 0 10px 0;">Matching Taxa</h4>
                    <div id="taxonomic-breadcrumb"></div>
                    <div id="results-list" style="font-size: 0.9rem; max-height: 150px; overflow-y: auto;"></div>
                    <button class="reset-btn" onclick="resetMatrix()">Reset Matrix</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="regions.js"></script>
<script src="traits.js"></script>
<script src="flydata.js"></script>
<script src="taxa.js"></script>

<script>
    /* --- SHARED STATE --- */
    let TOTAL_API_RESULTS = 0; 
    let MY_USER_ID = null;
    let MY_TOKEN = localStorage.getItem('inat_token') || "";
    let FINISHED_OBS_IDS = [];
    let OBSERVATION_QUEUE = [];
    let CURRENT_OBS_ID = null;
	let BATCH_SIZE = 30
    let CURRENT_COMMUNITY_ID = null;
    let CURRENT_PLACE_ID = "6712,1"; // Default: USA & Canada
    let API_BASE = "https://api.inaturalist.org/v1/observations?taxon_id=61858&only_id=false&fields=all&quality_grade=needs_id&order=asc";

let isPinned = false; 

function handleZoom(e) {
    const container = e.currentTarget;
    const img = container.querySelector('.main-photo');
    
    // Read current state from the element's dataset
    let zoomState = container.dataset.zoomState || 'none'; // 'none', 'active', or 'pinned'

    if (e.type === 'click') {
        if (zoomState === 'none') {
            // First click: Zoom in and start following mouse
            zoomState = 'active';
            container.classList.add('zoomed-active');
            container.classList.remove('zoomed-pinned');
        } else if (zoomState === 'active') {
            // Second click: Freeze (Pin) in place
            zoomState = 'pinned';
            container.classList.add('zoomed-pinned');
        } else {
            // Third click: Reset to normal
            zoomState = 'none';
            container.classList.remove('zoomed-active', 'zoomed-pinned');
            img.style.transformOrigin = `center center`;
        }
        container.dataset.zoomState = zoomState;
    }

    // Follow mouse only if state is 'active' (not pinned or none)
    if (zoomState === 'active' && (e.type === 'mousemove' || e.type === 'click')) {
        const rect = container.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / container.offsetWidth) * 100;
        const y = ((e.clientY - rect.top) / container.offsetHeight) * 100;
        img.style.transformOrigin = `${x}% ${y}%`;
    }
}

function handleDblClick(event) {
    if (!isZoomedIn) return;
    isPinned = !isPinned;
    event.currentTarget.classList.toggle('pinned', isPinned);
    
    // Reset translation when pinning starts
    if (isPinned) {
        translateX = 0; translateY = 0;
    }
}

// Add these to handle the "Grab" feel
function startDrag(e) { if(isPinned) isDragging = true; }
function stopDrag(e) { isDragging = false; }


    /* --- MODAL LOGIC --- */
function openIDModal() { 
    document.getElementById('modal-id').style.display = 'flex'; 

// Step A: Calculate matches
const filtered = flyData.filter(fly => {
    return Object.keys(currentFilters).every(key => {
        if (currentFilters[key] === null) return true;
        if (key === 'region') return fly.distribution && fly.distribution.includes(currentFilters[key]);
        if (fly[key] === undefined) return true;
        return fly[key] && fly[key].includes(currentFilters[key]);
    });
});

// Step B: Get the common group name
const common = getLowestCommonTaxon(filtered);

if (common && common.length > 0) {
        const lowestName = common[common.length - 1];
        const taxonInfo = taxa.find(t => t.name === lowestName);
        
        if (taxonInfo) {
            document.getElementById('suggested-id-area').innerHTML = "Suggestion: " + lowestName;
            document.getElementById('suggested-id-area').style.display = 'block';
            document.getElementById('manual-taxon-id').value = taxonInfo.taxonId;
        } else {
            // Case where common taxon name isn't in your taxa.js list
            document.getElementById('suggested-id-area').style.display = 'none';
            document.getElementById('manual-taxon-id').value = '';
        }
    } else {
        // THIS IS THE FIX: Clear everything if there are no matches
        document.getElementById('suggested-id-area').style.display = 'none';
        document.getElementById('manual-taxon-id').value = '';
    }
}

    function openCommentModal() { document.getElementById('modal-comment').style.display = 'flex'; }
    function closeModals() { 
        document.getElementById('modal-id').style.display = 'none'; 
        document.getElementById('modal-comment').style.display = 'none'; 
        document.getElementById('modal-location').style.display = 'none';
        document.getElementById('taxon-search-input').value = '';
        document.getElementById('search-results-dropdown').style.display = 'none';
        document.getElementById('manual-taxon-id').value = '';
    }


    async function submitManualID() {
        const tId = document.getElementById('manual-taxon-id').value;
        if (!tId) return;

        sendIdentification(CURRENT_OBS_ID, tId);
        closeModals();

        document.getElementById('manual-taxon-id').value = '';

	excludeAndNext(CURRENT_OBS_ID);
    }

    async function submitComment() {
        const body = document.getElementById('comment-body').value;
        if (!body) return;
        try {
            await fetch("https://api.inaturalist.org/v1/comments", {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${MY_TOKEN}` },
                body: JSON.stringify({ comment: { body: body, parent_id: CURRENT_OBS_ID, parent_type: "Observation" } })
            });
            closeModals();
            document.getElementById('comment-body').value = '';
        } catch (e) { alert("Comment failed"); }
    }

function toggleViewerPanel() {
    const viewerPanel = document.querySelector('.viewer-panel');
    const btn = document.getElementById('toggle-viewer-btn');
    
    if (viewerPanel.style.display === 'none') {
        viewerPanel.style.display = 'block';
        document.body.classList.remove('wide-layout');
        btn.innerText = "Hide iNat interface";
    } else {
        viewerPanel.style.display = 'none';
        document.body.classList.add('wide-layout');
        btn.innerText = "Show iNat interface";
    }
}

function copyNarrativeToClipboard() {
    const content = document.getElementById('summary-content');
    const btn = document.getElementById('copy-narrative-btn');
    
    // We use .innerText to get the text without the HTML <strong> tags
    const textToCopy = content.innerText;

    navigator.clipboard.writeText(textToCopy).then(() => {
        // Visual feedback that it worked
        const originalText = btn.innerText;
        btn.innerText = "Copied!";
        btn.style.background = "#eef9ff";
        
        // Reset the button after 2 seconds
        setTimeout(() => {
            btn.innerText = originalText;
            btn.style.background = "#f8f9fa";
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy: ', err);
    });
}

    /* --- iNAT VIEWER LOGIC --- */
    function isTokenValid(token) {
        if (!token || token.length < 20) return false;
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            return Date.now() < (payload.exp * 1000);
        } catch (e) { return false; }
    }

    async function updateStatusUI() {
        const statusEl = document.getElementById('token-status');
        const controls = document.getElementById('token-controls');
        const viewerPanel = document.querySelector('.viewer-panel');
	const toggleBtn = document.getElementById('toggle-viewer-btn');
	const toggleLocBtn = document.getElementById('change-loc-btn');
        if (!isTokenValid(MY_TOKEN)) {
            statusEl.innerText = "";<!--versus "EXPIRED/MISSING" -->
            statusEl.className = "";<!-- versus "status-bad" -->
            controls.classList.remove('hidden');
            if (viewerPanel) viewerPanel.style.display = 'none';
            if (toggleBtn) toggleBtn.classList.add('hidden');
	    if (toggleLocBtn) toggleLocBtn.classList.add('hidden');
            document.body.classList.add('wide-layout'); 
            return;
        }
        try {
            const res = await fetch("https://api.inaturalist.org/v1/users/me", {
                headers: { "Authorization": `Bearer ${MY_TOKEN}` }
            });
            const userData = await res.json();
            if (res.ok && userData.results?.length > 0) {
                const user = userData.results[0];
                MY_USER_ID = user.id;
                statusEl.innerHTML = `<a href="https://www.inaturalist.org/identifications/${user.login}" target="_blank" style="color: white; text-decoration: none;">ACTIVE: ${user.login}</a>`;
                statusEl.className = "status-good";
                controls.classList.add('hidden');
		if (toggleLocBtn) toggleLocBtn.classList.remove('hidden');
                if (toggleBtn) toggleBtn.classList.remove('hidden');
                if (viewerPanel) viewerPanel.style.display = 'block';
                document.body.classList.remove('wide-layout');
            } else { throw new Error(); }
        } catch (e) {
            statusEl.innerText = "TOKEN ERROR";
            statusEl.className = "status-bad";
            controls.classList.remove('hidden');
            if (toggleBtn) toggleBtn.classList.add('hidden');
	    if (toggleLocBtn) toggleLocBtn.classList.add('hidden');
            if (viewerPanel) viewerPanel.style.display = 'none';
            document.body.classList.add('wide-layout');
        }
    }

    async function fetchObservations() {
        if (!MY_USER_ID) { await updateStatusUI(); if (!MY_USER_ID) return; }
        if (OBSERVATION_QUEUE.length > 0) { showNextFromQueue(); return; }
        const queueCountEl = document.getElementById('queue-count');
        queueCountEl.innerText = " (Refilling buffer...)";
        try {
            const excludedIds = FINISHED_OBS_IDS.length > 0 ? `&not_id=${FINISHED_OBS_IDS.join(',')}` : '';
            const filteredURL = `${API_BASE}&per_page=${BATCH_SIZE}&place_id=${CURRENT_PLACE_ID}&viewer_id=${MY_USER_ID}&reviewed=false&without_ident_user_id=${MY_USER_ID}${excludedIds}`;
            const response = await fetch(filteredURL, { headers: { "Authorization": `Bearer ${MY_TOKEN}` } });
            const data = await response.json();
            TOTAL_API_RESULTS = data.total_results || 0;
            if (data.results?.length > 0) {
                OBSERVATION_QUEUE = data.results;
                showNextFromQueue();
            } else {
                queueCountEl.innerText = " (No more observations found)";
		alert("No more observations found");
            }
        } catch (error) {
            queueCountEl.innerText = " (Error loading data)";
        }
    }

async function showNextFromQueue() {
    if (OBSERVATION_QUEUE.length === 0) { fetchObservations(); return; }
    const obs = OBSERVATION_QUEUE.shift();
    CURRENT_OBS_ID = obs.id;
    document.getElementById('queue-count').innerText = `  (${TOTAL_API_RESULTS+OBSERVATION_QUEUE.length-BATCH_SIZE} observations)`; // ${OBSERVATION_QUEUE.length} buffered not shown
    //Capture the community taxon ID from the queue data	
    CURRENT_COMMUNITY_ID = obs.taxon?.id || null;

    let geoHierarchy = "Location Unknown";
    let locationTerms = [];

    if (obs.place_ids?.length > 0) {
        try {
            // Using the API to get the names of the places
            const pRes = await fetch(`https://api.inaturalist.org/v1/places/${obs.place_ids.join(',')}`);
            const pData = await pRes.json();
            
            // We want the names of countries (admin 0), states (10), and counties (20)
            const places = pData.results.filter(p => [0, 10, 20].includes(p.admin_level));
            locationTerms = places.map(p => p.name);
            geoHierarchy = places.sort((a,b) => a.admin_level - b.admin_level).map(p => p.name).join(' » ');
            
        } catch (e) { console.error("Place fetch failed", e); }
    }

    autoSetRegionFromLocality(locationTerms);

    renderObservations([obs], geoHierarchy);
}



function autoSetRegionFromLocality(terms) {
    if (!terms || terms.length === 0) return;

    // Look for a match in your regions.js data
    // We check from most specific to most general (usually the order in the array)
    const match = regions.find(r => 
        terms.some(term => term.toLowerCase() === r.name.toLowerCase())
    );

    if (match) {
        currentFilters.region = match.code;
        if (!answerOrder.includes('region')) {
            answerOrder.push('region');
        }
        // Update the UI to reflect the automatically selected region
        updateUI();
        console.log(`Auto-detected region: ${match.name}`);
    }
   jumpToNextQuestion() // could turn off.
}


    function renderObservations(observations, geoHierarchy) {
	const grid = document.getElementById('observation-grid');
        grid.innerHTML = observations.map(obs => {
            const photos = obs.observation_photos || [];
        const mainPhoto = photos[0]?.photo.url.replace("square", "large") || "";
        const mainPhotoOrig = photos[0]?.photo.url.replace("square", "original") || "";

        // Create the thumbnails HTML if there is more than 1 photo
        const thumbnailsHtml = photos.length > 1 ? `
            <div class="thumb-strip" style="display: flex; gap: 4px; padding: 5px; overflow-x: auto; background: #f0f0f0;">
                ${photos.map((p, idx) => `
                    <img src="${p.photo.url}" 
                         style="width: 45px; height: 45px; object-fit: cover; cursor: pointer; border: 2px solid ${idx === 0 ? '#2980b9' : 'transparent'};" 
                         onclick="
                            event.stopPropagation();
                            const card = this.closest('.card');
                            const largeUrl = '${p.photo.url.replace("square", "large")}';
                            const origUrl = '${p.photo.url.replace("square", "original")}';
                            card.querySelector('.main-photo').src = largeUrl;
                            this.parentElement.querySelectorAll('img').forEach(i => i.style.borderColor = 'transparent');
                            this.style.borderColor = '#2980b9';
                         ">
                `).join('')}
            </div>
        ` : '';

        const monthNames = [
   	 "January", "February", "March", "April", "May", "June",
 	   "July", "August", "September", "October", "November", "December"
	];
	const dateDetails = obs.observed_on_details;
	const monthName = monthNames[dateDetails.month - 1]; // -1 because arrays are 0-indexed
	const formattedDate = `${monthName} ${dateDetails.day}, ${dateDetails.year}`;

 	// 1. Create a combined list of all Comments and all Identifications
        const allDiscussion = [
	    ...(obs.description ? [{
	        user: obs.user?.login || "Observer",
	        body: obs.description,
	        type: 'note' // New type for styling
	    }] : []),
            ...(obs.identifications || []).map(i => ({ 
                user: i.user.login, 
                // If there's no body text, we show a default status message
                body: i.body && i.body.trim() !== "" ? i.body : "added an identification.", 
                taxonName: i.taxon?.preferred_common_name || i.taxon?.name,
                type: 'id'
            })),
            ...(obs.comments || []).map(c => ({ 
                user: c.user.login, 
                body: c.body, 
                type: 'comment' 
            }))
        ];
            return `
                <div class="card" data-id="${obs.id}">
                    <div class="img-container" 
		     onclick="handleZoom(event)" 
		     onmousemove="handleZoom(event)"
		     ondblclick="handleDblClick(event)"
		     onmousedown="startDrag(event)"
		     onmouseup="stopDrag(event)"
		     onmouseleave="stopDrag(event)">
            <img src="${mainPhoto}" class="main-photo">
            ${thumbnailsHtml}
            <div style="position:absolute; top:10px; right:10px; background:rgba(0,0,0,0.5); color:white; padding:2px 6px; border-radius:4px; font-size:0.7rem; pointer-events:none;">
                Click to Zoom
            </div>
        </div>

          <div class="card-content-split">
                    <div class="info">
                        <a href="https://www.inaturalist.org/observations/${obs.id}" target="_blank" style="text-decoration:none; color:inherit;">
                            <h2 style="margin:0; font-size:1.2rem;">${obs.taxon?.preferred_common_name || "Unknown"}</h2>
			    <style="color:#666; font-size:0.8rem;">${obs.taxon?.rank && obs.taxon.rank !== 'species' ? obs.taxon.rank.charAt(0).toUpperCase() + obs.taxon.rank.slice(1) + ' ' : ''}<i>${obs.taxon?.name || "Unknown"}</i></style>
                        </a>
		      <div class="obs-date" style="font-size:0.75rem; color:#555; margin-top:4px;">
		        <strong>DATE:</strong> ${formattedDate}
		    </div>
                        <div class="geo-hierarchy"><span style="font-size:0.7em; font-weight:bold;">LOCALITY:</span><br>${geoHierarchy}</div>
                    </div>
                    <div class="btn-group">
			<button class="btn-post" onclick="postImmediateID()">POST RESULTS & NEXT</button>
                        <button class="btn-id" onmouseover="this.style.filter='brightness(1.2)'" onmouseout="this.style.filter='brightness(1)'" onclick="sendIdentification(${obs.id}, ${obs.taxon?.id});excludeAndNext(${obs.id});">AGREE & NEXT</button>
			<button class="btn-action" onmouseover="this.style.filter='brightness(1.2)'" onmouseout="this.style.filter='brightness(1)'" onclick="openIDModal()">ADD OTHER ID & NEXT</button>
                        <button class="btn-skip" onmouseover="this.style.filter='brightness(0.8)'" onmouseout="this.style.filter='brightness(1)'" onclick="excludeAndNext(${obs.id})">SKIP</button>
                        <button class="btn-action" onmouseover="this.style.filter='brightness(1.2)'" onmouseout="this.style.filter='brightness(1)'" onclick="openCommentModal()">COMMENT</button>
                    </div>
      	 </div> 
			<div class="comments-section" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee; font-size: 0.85rem; color: #444; max-height: 200px; overflow-y: auto;">
                <strong style="font-size: 0.7rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px;">Activity & Discussion</strong>
                ${allDiscussion.length > 0 
                    ? allDiscussion.map(item => `
                         <div class="comment-item" style="margin-bottom: 8px; border-bottom: 1px solid #f0f0f0; padding-bottom: 4px;">
                            <strong>${item.user}</strong> 
                            ${item.type === 'id' ? `<span style="color:#2980b9; font-weight:bold;"> [ID: ${item.taxonName}]</span>` : ''}: 
                            <span style="${item.type === 'id' && item.body === 'added an identification.' ? 'font-style: italic; color: #888;' : ''}">
                                ${item.body}
                            </span>
                         </div>
                    `).join('') 
                    : '<div style="color: #999; font-style: italic;">No activity yet.</div>'
                }
            </div>

                </div>`;
        }).join('');
    }

    async function sendIdentification(obsId, taxonId) {
        try {
            await fetch("https://api.inaturalist.org/v1/identifications", {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${MY_TOKEN}` },
                body: JSON.stringify({ identification: { observation_id: obsId, taxon_id: taxonId, disagreement: true } })
            });
        } catch (e) { console.error("ID Failed", e); }
    }

async function setCommunityTaxonStatus(taxonInfo) {
    if (!CURRENT_OBS_ID || !MY_TOKEN) {
        console.error("Missing Observation ID or Token");
        return;
    }

    //storing constants before starting timer
    const COMM_CURRENT = CURRENT_OBS_ID
    const TAXON_OLD = taxonInfo

    // 10 second delay for server processing of initial ID
    await new Promise(resolve => setTimeout(resolve, 10000));

    const response = await fetch(`https://api.inaturalist.org/v1/observations/${COMM_CURRENT}`);
    const data = await response.json();
    const latestCommunityID = data.results[0].taxon?.id;

    // Compare: Only vote if new ID matches existing community ID
    if (TAXON_OLD.rank !== "species" && latestCommunityID === TAXON_OLD.taxonId) {
                console.log(`ID is at rank: ${TAXON_OLD.rank}. Sending cannot improve community ID...`);

	    try {
	    	  const response = await fetch(`https://api.inaturalist.org/v1/votes/vote/observation/${COMM_CURRENT}`, {
	            method: "POST",
	            headers: {
	                "Content-Type": "application/json",
	                "Authorization": `Bearer ${MY_TOKEN}`
	            },
	            body: JSON.stringify({
	                vote: "down",
	                scope: "needs_id"
	            })
	           });
	
	        if (response.ok) {
	            console.log(`Successfully voted to end "Needs ID" for observation ${COMM_CURRENT}`);
	        } else { 
			console.error("Failed to update status:", await response.json());
		}
	    } catch (e) {
	        console.error("Network error:", e);
	    }   

    }
}

async function postImmediateID() {
    // 1. Calculate the matching taxa based on current filters
    const filtered = flyData.filter(fly => {
        return Object.keys(currentFilters).every(key => {
            if (currentFilters[key] === null) return true;
            if (key === 'region') return fly.distribution && fly.distribution.includes(currentFilters[key]);
            if (fly[key] === undefined) return true;
            return fly[key] && fly[key].includes(currentFilters[key]);
        });
    });

    // 2. Get the suggested taxon name
    const common = getLowestCommonTaxon(filtered);
    let taxonInfo = null; // so that it exists outside the next if area

    if (common && common.length > 0) {
        const lowestName = common[common.length - 1];
        taxonInfo = taxa.find(t => t.name === lowestName);
        
        if (taxonInfo && taxonInfo.taxonId) {
            // --- WHAT DO IF NOT A SPECIES LEVEL ID --
                setCommunityTaxonStatus(taxonInfo);
           

            // 3. Submit immediately to iNat
            sendIdentification(CURRENT_OBS_ID, taxonInfo.taxonId);
            console.log(`Successfully posted ID: ${lowestName}`);
        } else {
            alert("Could not find a Taxon ID for this match in taxa.js");
        }
    } else {
        alert("No match found in the matrix to post!");
    }
      //only post comment if new ID is not agreeing or it's stuck above genus
      if (taxonInfo && CURRENT_COMMUNITY_ID !== taxonInfo.taxonId || taxonInfo && taxonInfo.rank !== "species") {
	// 3. POST THE NARRATIVE COMMENT AT THE END
            const narrativeText = document.getElementById('summary-content').innerHTML;
            const placeholder = "Select traits to generate description.";
            
            if (narrativeText && narrativeText !== placeholder) {
                try {
                    fetch("https://api.inaturalist.org/v1/comments", {
                        method: "POST",
                        headers: { 
                            "Content-Type": "application/json", 
                            "Authorization": `Bearer ${MY_TOKEN}` 
                        },
                        body: JSON.stringify({ 
                            comment: { 
                                body: narrativeText, 
                                parent_id: CURRENT_OBS_ID, 
                                parent_type: "Observation" 
                            } 
                        })
                    });
                    console.log("Narrative comment posted.");
                } catch (e) {
                    console.error("Comment failed to post", e);
                }
            }
       }
   excludeAndNext(CURRENT_OBS_ID);

}


    function excludeAndNext(obsId) {
        if (!FINISHED_OBS_IDS.includes(obsId)) FINISHED_OBS_IDS.push(obsId);
        resetMatrix();
        showNextFromQueue();
    }

    function updateTokenManual() {
        const input = document.getElementById('token-input');
        let val = input.value.trim();
        const match = val.match(/"([^"]{20,})"/);
        if (match) val = match[1];
        MY_TOKEN = val;
        localStorage.setItem('inat_token', val);
        OBSERVATION_QUEUE = [];
        updateStatusUI().then(fetchObservations);
        input.value = "";
    }

    /* --- MATRIX CORE LOGIC --- */
    let currentFilters = { region: null }; 
    let answerOrder = []; 
    let skippedQuestions = []; 
    let activeId = null;

    function initMatrix() {
        if (typeof traits !== 'undefined') traits.forEach(t => { currentFilters[t.id] = null; });
        renderMenu();
    }

    function calculateTraitUtility(traitId, filteredFlies) {
	// 1. Get a list of unique species names currently in the filtered list
	const uniqueSpeciesCount = new Set(filteredFlies.map(fly => fly.species)).size;

    	// 2. If there's only 1 species (or 0) left, this trait has no diagnostic value
    	if (uniqueSpeciesCount <= 1) return 0;

        const counts = {};
        let totalMatches = 0;

        filteredFlies.forEach(fly => {
	    // Get unique options for this species
            const flyOptions = (traitId === 'region') ? fly.distribution : fly[traitId];

           // Treat each option as a full vote from that species
           // This ignores the 'uncertainty' of having multiple options
           if (flyOptions && Array.isArray(flyOptions)) {
            flyOptions.forEach(opt => {
                counts[opt] = (counts[opt] || 0) + 1;
                });
            }
        });

    // Calculate entropy based on species counts, not weighted fractions
    let entropy = 0;
    Object.values(counts).forEach(speciesCount => {
        const p = speciesCount / filteredFlies.length; 
        entropy -= p * Math.log(p);
    });
    
    return entropy.toFixed(3);
    }

    function renderMenu() {
        const menu = document.getElementById('question-menu');
        const currentMatches = flyData.filter(fly => {
            return Object.keys(currentFilters).every(key => {
                if (currentFilters[key] === null) return true;
                if (key === 'region') return fly.distribution && fly.distribution.includes(currentFilters[key]);
		if (fly[key] === undefined) return true;
                return fly[key] && fly[key].includes(currentFilters[key]);
            });
        });

        const allQuestions = [{ id: 'region', title: 'Region', weight: 10}, ...traits];
        const answered = allQuestions.filter(q => currentFilters[q.id] !== null || skippedQuestions.includes(q.id));
        const unanswered = allQuestions.filter(q => currentFilters[q.id] === null && !skippedQuestions.includes(q.id));

        answered.sort((a, b) => answerOrder.indexOf(a.id) - answerOrder.indexOf(b.id));
        const sortedUnanswered = unanswered.map(q => {
            const hValue = parseFloat(calculateTraitUtility(q.id, currentMatches));
            const score = hValue * (q.weight || 1);
            const intensity = Math.min(score / 5, 1); 
            return { ...q, score, bgColor: `hsl(30, ${intensity * 100}%, ${95 - (intensity * 25)}%)` };
        }).sort((a, b) => b.score - a.score);

        // 1. Check if we should show the "no more diagnostic questions" message
        const allUnansweredAreZero = sortedUnanswered.length > 0 && sortedUnanswered.every(q => q.score <= 0);
        let messageHtml = "";
        if (allUnansweredAreZero) {
            messageHtml = `<div style="padding: 10px; font-size: 0.75rem; color: #888; font-style: italic; border-left: 3px solid #ccc; margin: 5px 0; background: #f9f9f9;">
                No more diagnostic traits available. Remaining questions are for confirmation only.
            </div>`;
        }

        const finalOrder = [...answered.map(q => ({ ...q, bgColor: '#ffffff' })), ...sortedUnanswered];

        menu.innerHTML = finalOrder.map((q, index) => {
            const isAnswered = currentFilters[q.id] !== null;
            const isFirstUnanswered = index === answered.length;
            
            // 2. Insert the message right before the first unanswered question if all scores are 0
            let itemHtml = `
                <div class="menu-item ${activeId === q.id ? 'active' : ''}" 
                     style="background-color: ${activeId === q.id ? '' : q.bgColor};" 
                     onclick="selectQuestion('${q.id}')">
                    <span>${q.title}</span>
                    ${isAnswered ? '✓' : ''}
                </div>`;
                
            return (isFirstUnanswered ? messageHtml : "") + itemHtml;
        }).join('');
    }

    function selectQuestion(id) {
    activeId = id;
    renderMenu();

    // 1. Calculate matches and diagnostic state
    const currentMatches = getFilteredFlies(); 
    const unanswered = traits.filter(q => currentFilters[q.id] === null && !skippedQuestions.includes(q.id));
    
    // Check if everything left is 0 score (Confirmation Mode)
    const isConfirmationMode = unanswered.every(q => {
        const hValue = parseFloat(calculateTraitUtility(q.id, currentMatches));
        return (hValue * (q.weight || 1)) <= 0;
    });

    // 2. Check if a valid iNaturalist token is present
    const hasValidToken = isTokenValid(MY_TOKEN);

    const area = document.getElementById('active-question-area');
    
    // Handle Region (Usually stays as a standard select)
    if (id === 'region') {
        const currentRegionObj = regions.find(r => r.code === currentFilters.region);
        area.innerHTML = `
            <h4>Select Region</h4>
            <div style="display: flex; gap: 5px; margin-bottom:10px;">
                <input list="regions-list" placeholder="Type region..." 
                       value="${currentRegionObj ? currentRegionObj.name : ''}" oninput="handleRegionChange(this.value)" style="flex:1; padding:8px;">
            </div>
            <datalist id="regions-list">${regions.map(r => `<option value="${r.name}">${r.code}</option>`).join('')}</datalist>
            <button class="reset-btn" style="background:#95a5a6" onclick="skipQuestion('region')">Skip</button>
        `;
    } else {
        const trait = traits.find(t => t.id === id);
        
	const linkHtml = trait.link 
            ? `<a href="${trait.link}" target="_blank" style="text-decoration:none; margin-left:auto; font-size:2rem; color:#2980b9; line-height:1;" title="View trait details">&#9432;</a>` 
            : "";

        // 3. Determine which button to show
        let actionButtonHtml = "";
        if (isConfirmationMode && hasValidToken) {
            // Show "Post Results" if in confirmation mode and logged in
            actionButtonHtml = `<button class="btn-post" style="width:100%; margin-top:10px;" onclick="postImmediateID()">Post Results & Next</button>`;
        } else if (!isConfirmationMode) {
            // Show "Skip" if there are still useful questions to answer
            actionButtonHtml = `<button class="reset-btn" style="background:#95a5a6" onclick="skipQuestion('${id}')">Skip</button>`;
        }
        // If it's confirmation mode but NO token, we show nothing (as requested)

        area.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: baseline;">
      		  <h4 style="margin: 0; padding-bottom: 10px;">${trait.title}</h4>
       		 ${linkHtml}
    		</div>
            ${trait.options.map(opt => `
                <button class="option ${currentFilters[id] === opt.label ? 'active' : ''}" 
                        onclick="handleTraitSelection('${id}', '${opt.label}')">${opt.label}</button>
            `).join('')}
            ${actionButtonHtml}
        `;
    }

    // Scroll Logic
    setTimeout(() => {
        const item = document.querySelector(`.menu-item[onclick*="'${id}'"]`);
        if (item) item.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 50);
}


function getFilteredFlies() {
    return flyData.filter(fly => {
        return Object.keys(currentFilters).every(key => {
            if (currentFilters[key] === null) return true;
            if (key === 'region') return fly.distribution && fly.distribution.includes(currentFilters[key]);
            if (fly[key] === undefined) return true;
            return fly[key] && fly[key].includes(currentFilters[key]);
        });
    });
}

    function handleRegionChange(val) {
        const foundRegion = regions.find(r => r.name.toUpperCase() === val.trim().toUpperCase() || r.code.toUpperCase() === val.trim().toUpperCase());
        if (foundRegion) {
            currentFilters.region = foundRegion.code; 
            if (!answerOrder.includes('region')) answerOrder.push('region');
            skippedQuestions = skippedQuestions.filter(sid => sid !== 'region');
            setTimeout(jumpToNextQuestion, 300);
        } else { currentFilters.region = null; }
        updateUI();
    }

    function handleTraitSelection(traitId, value) {
        if (currentFilters[traitId] === value) {
            currentFilters[traitId] = null;
            answerOrder = answerOrder.filter(id => id !== traitId);
        } else {
            currentFilters[traitId] = value;
            skippedQuestions = skippedQuestions.filter(sid => sid !== traitId);
            if (!answerOrder.includes(traitId)) answerOrder.push(traitId);
            setTimeout(jumpToNextQuestion, 300);
        }
        selectQuestion(traitId);
        updateUI();
    }

    function skipQuestion(id) {
        if (!answerOrder.includes(id)) answerOrder.push(id);
        if (!skippedQuestions.includes(id)) skippedQuestions.push(id);
        currentFilters[id] = null;
        if (activeId === id) selectQuestion(id); 
        setTimeout(jumpToNextQuestion, 200);
        updateUI();
    }

    function updateUI() {
        const filtered = flyData.filter(fly => {
            return Object.keys(currentFilters).every(key => {
                if (currentFilters[key] === null) return true;
                if (key === 'region') return fly.distribution && fly.distribution.includes(currentFilters[key]);
		if (fly[key] === undefined) return true;
                return fly[key] && fly[key].includes(currentFilters[key]);
            });
        });

        const breadcrumbArea = document.getElementById('taxonomic-breadcrumb');
        const commonTaxa = getLowestCommonTaxon(filtered);
        
        // 1. Taxonomic Breadcrumb (from index.html)
        if (commonTaxa && commonTaxa.length > 0) {
            breadcrumbArea.innerHTML = `
                <div class="breadcrumb-container">
                    ${commonTaxa.map((taxonName, index) => {
                                // Find the taxon object in your database to get the ID
                                const taxonData = taxa.find(t => t.name === taxonName);
                                const url = taxonData ? `https://www.inaturalist.org/taxa/${taxonData.taxonId}` : '#';
                                const isActive = index === commonTaxa.length - 1 ? 'breadcrumb-active' : '';
                
                                return `
                                    <span class="breadcrumb-item ${isActive}">
                                        » <a href="${url}" target="_blank" style="color: inherit; text-decoration: none;">${taxonName}</a>
                                    </span>
                                `;
                            }).join('')}
                </div>
            `;
        } else {
            breadcrumbArea.innerHTML = '';
        }

        // 2. Results List (from index.html)
        const resultsList = document.getElementById('results-list');
        if (filtered.length === 0) {
            resultsList.innerHTML = "<div style='color: #ff7675;'>No matches.</div>";
        } else {
            resultsList.innerHTML = filtered.map(f => `
                <div style="margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px;">
                 • <i>${f.species}</i> ${f.m_or_f ? `(${f.m_or_f})` : ''}
                </div>
            `).join('');
        }

        // 3. Narrative logic (from index.html)
        let narrative = [];
        if (currentFilters.region) {
            const regionName = regions.find(r => r.code === currentFilters.region)?.name || currentFilters.region;
            narrative.push(`The record was observed in <strong>${regionName}</strong>.`);
        }

        Object.keys(currentFilters).forEach(key => {
            if (key !== 'region' && currentFilters[key]) {
                const trait = traits.find(t => t.id === key);
                if (trait) {
                    const selectedOption = trait.options.find(opt => opt.label === currentFilters[key]);
                    if (selectedOption && selectedOption.description) narrative.push(selectedOption.description);
                }
            }
        });
        
        const summaryBox = document.getElementById('summary-content');
        if (narrative.length > 0) {
            if (filtered.length === 0) {
                narrative.push("<br><br><strong>No matching species found.</strong>");
            } else {
                const uniqueSexes = [...new Set(filtered.map(f => f.m_or_f).filter(Boolean))];
                const sexPrefix = uniqueSexes.length === 1 ? `${uniqueSexes[0]} ` : "";
                
                let lowestTaxonDisplay = "Unknown";
                if (commonTaxa && commonTaxa.length > 0) {
                    const currentIndex = commonTaxa.length - 1;
                    const rawLowest = commonTaxa[currentIndex];
                    lowestTaxonDisplay = rawLowest;

                    const sampleTaxonomy = filtered[0].taxonomy;
                    const nextLevel = sampleTaxonomy[currentIndex + 1];

                    if (!rawLowest.includes(" ") && nextLevel && nextLevel.includes(" ")) {
                        lowestTaxonDisplay = `<i>${rawLowest}</i>`;
                    }
                }

                let resultText = "";
                if (filtered.length === 1) {
                    resultText = `${sexPrefix ? 'a ' + sexPrefix : ''}<i>${filtered[0].species}</i>.`;
                } else {
                    const speciesList = [...new Set(filtered.map(f => f.species))];
                    const speciesFormatted = speciesList.map(s => `<i>${s}</i>`).reduce((acc, curr, i) => {
                        return acc + (i === 0 ? "" : i === speciesList.length - 1 ? " or " : ", ") + curr;
                    }, "");
                    

                    if (speciesList.length === 1 && lowestTaxonDisplay.includes(speciesList[0])) {
                            resultText = `${sexPrefix ? 'a ' + sexPrefix : ''}<i>${filtered[0].species}</i>.`;
                        } else {
                            resultText = `a member of the group ${lowestTaxonDisplay}, specifically ${sexPrefix ? `a ${sexPrefix}` : ''}${speciesFormatted}.`;
                        }
                        
                }
                narrative.push(`<br><br>Therefore, we can narrow this down to ${resultText}`);
            }
            narrative.push(`<br><br>See tools at <a href="https://sites.google.com/view/flyguide/species-guides/calliphoridae">https://sites.google.com/view/flyguide/species-guides/calliphoridae</a>.`);
            summaryBox.innerHTML = narrative.join(" ");
        } else {
            summaryBox.innerHTML = "Select traits to generate description.";
        }
        renderMenu();
    }

    function getLowestCommonTaxon(filteredResults) {
        if (filteredResults.length === 0) return null;
        let common = [...filteredResults[0].taxonomy];
        filteredResults.forEach(fly => {
            for (let i = 0; i < common.length; i++) {
                if (fly.taxonomy[i] !== common[i]) { common = common.slice(0, i); break; }
            }
        });
        return common;
    }

    function resetMatrix() {
        currentFilters = { region: null };
        traits.forEach(t => { currentFilters[t.id] = null; });
        answerOrder = []; skippedQuestions = []; activeId = null;
        document.getElementById('active-question-area').innerHTML = '<div style="color:#999; text-align:center; padding-top:50px;">Select a trait to begin.</div>';
        updateUI();
    }

    window.onload = () => {
        initMatrix();
        updateStatusUI().then(() => { if (MY_TOKEN) fetchObservations(); });
    };


let searchTimeout = null;

async function searchTaxa(query) {
    const dropdown = document.getElementById('search-results-dropdown');
    
    // Don't search for very short strings
    if (query.length < 3) {
        dropdown.style.display = 'none';
        return;
    }

    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(async () => {
        try {
            const response = await fetch(`https://api.inaturalist.org/v1/taxa/autocomplete?q=${encodeURIComponent(query)}`);
            const data = await response.json();
            
            if (data.results.length > 0) {
                dropdown.innerHTML = data.results.map(t => `
                    <div class="search-result-item" 
                         style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 0.9rem;"
                         onclick="selectTaxon('${t.id}', '${t.name}')">
                        <strong>${t.name}</strong> <small>(${t.preferred_common_name || ''})</small>
                    </div>
                `).join('');
                dropdown.style.display = 'block';
            } else {
                dropdown.style.display = 'none';
            }
        } catch (e) {
            console.error("Taxon search failed", e);
        }
    }, 300); // 300ms delay to wait for user to stop typing
}

function selectTaxon(id, name) {
    document.getElementById('manual-taxon-id').value = id;
    document.getElementById('taxon-search-input').value = name;
    document.getElementById('search-results-dropdown').style.display = 'none';
}

function openLocationModal() {
    document.getElementById('modal-location').style.display = 'flex';
    document.getElementById('new-place-id').value = CURRENT_PLACE_ID;
}

function updateLocation() {
    const newId = document.getElementById('new-place-id').value.trim();
    if (newId) {
        CURRENT_PLACE_ID = newId;
        OBSERVATION_QUEUE = []; // Clear current buffer
        FINISHED_OBS_IDS = [];  // Optional: Reset excluded list if changing regions
        closeModals();
        fetchObservations();    // Trigger new search
    }
}


let locationSearchTimeout = null;

async function searchPlaces(query) {
    const dropdown = document.getElementById('location-results-dropdown');
    
    if (query.length < 3) {
        dropdown.style.display = 'none';
        return;
    }

    clearTimeout(locationSearchTimeout);
    locationSearchTimeout = setTimeout(async () => {
        try {
            // Fetch places from iNaturalist
            const response = await fetch(`https://api.inaturalist.org/v1/places/autocomplete?q=${encodeURIComponent(query)}`);
            const data = await response.json();
            
            if (data.results.length > 0) {
                dropdown.innerHTML = data.results.map(p => `
                    <div class="search-result-item" 
                         style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 0.9rem; color: #333; text-align: left;"
                         onclick="selectPlace('${p.id}', '${p.display_name}')">
                        <strong>${p.name}</strong> <small style="color:#888;">(${p.display_name})</small>
                    </div>
                `).join('');
                dropdown.style.display = 'block';
            } else {
                dropdown.style.display = 'none';
            }
        } catch (e) {
            console.error("Location search failed", e);
        }
    }, 300);
}

function selectPlace(id, displayName) {
    document.getElementById('new-place-id').value = id;
    document.getElementById('location-search-input').value = displayName;
    document.getElementById('location-results-dropdown').style.display = 'none';
}


function jumpToNextQuestion() {
    // 1. Get the list of questions in the same order they appear in the menu
    const currentMatches = flyData.filter(fly => {
        return Object.keys(currentFilters).every(key => {
            if (currentFilters[key] === null) return true;
            if (key === 'region') return fly.distribution && fly.distribution.includes(currentFilters[key]);
            if (fly[key] === undefined) return true;
            return fly[key] && fly[key].includes(currentFilters[key]);
        });
    });

    const allQuestions = [{ id: 'region', title: 'Region', weight: 10}, ...traits];
    
    // 2. Filter for only unanswered and unskipped questions
    const remaining = allQuestions.filter(q => currentFilters[q.id] === null && !skippedQuestions.includes(q.id));

    // 3. Sort them by score (matches your renderMenu logic)
    const sortedRemaining = remaining.map(q => {
        const hValue = parseFloat(calculateTraitUtility(q.id, currentMatches));
        const score = hValue * (q.weight || 1);
        return { ...q, score };
    }).sort((a, b) => b.score - a.score);

    // 4. If there's a valid next question, select it
    if (sortedRemaining.length > 0 && sortedRemaining[0].score > 0) {
        selectQuestion(sortedRemaining[0].id);
    }
}


</script>

<div class="about-section">
    <h3>About this Tool</h3>
    <p>
        Built by Even Dankowicz, this workspace is designed to streamline the identification of <i>Lucilia</i> flies 
        by combining a character-based matrix with the iNaturalist verification queue. 
        Select traits from the menu to filter matching species and generate a diagnostic narrative.
		<p>A few important functions that may not be obvious:
			<ul>
		  <li>Authenticating your iNat account with the iNat API unlocks a set of functions equivalent to the 'Identify' tool.</li>
		  <li>If your ID is above species level and the same as the new community ID, the 'Post Results' button will mark "Based on the evidence, can the Community Taxon still be confirmed or improved?" as "No, it's as good as it can be."</li>
		  <li>If your ID is not an agreement with an existing species-level community ID, the 'Post Results' button will paste a description of your ID in a comment.</li>
		  <li>Like in the 'Identify' tool, clicking on the current community ID will open the observation in a new tab.</li>
			<li>Clicking on your username in the top left will open your 'identifications' page on iNaturalist, in case you want to go back to an observation you've recently IDed.</li>
			</ul>
		</p>
	<p>Most of the features used in this key are explained in my <a href="lucilia_us_canada.pdf">illustrated guide to Greenbottle Flies (Calliphoridae: <i>Lucilia</i>) of the USA and Canada</a>. Many features are also shown in <a href="https://cjai.biologicalsurvey.ca/wp-content/uploads/2021/01/jwm_39.pdf">Jones et al (2019)</a>, which is the best resource to start identifying specimens under a microscope. For my other fly ID resources, visit <a href="https://sites.google.com/view/flyguide/">https://sites.google.com/view/flyguide/</a>.
	<br><br>
	<p>I refined this dataset by studying preserved specimens, live flies, and photos.
	A lot of the trait and distribution records were initially derived from the following references:
	<p>
	Falk, 2016. British Blowflies (Calliphoridae) and Woodlouse Flies (Rhinophoridae). Draft Key March 2016. https://quelestcetanimal-lagalerie.com/wp-content/uploads/2017/01/testkeytobritishblowflies132016.pdf 
	<p>Hall, Townsend, 1977. The Blow Flies of Virginia (Diptera: Calliphoridae). Virginia Tech Research Division Bulletin 123.
	<p>Jones, Whitworth, Marshall, 2019. Blow flies of North America: Keys to the subfamilies and genera of Calliphoridae, and to the species of the subfamilies Calliphorinae, Luciliinae and Chrysomyinae. Canadian Journal of Arthropod Identification. 39. https://cjai.biologicalsurvey.ca/jwm_39/jwm_39.html 
	<p>Marshall, Whitworth, Roscoe, 2011. Blow flies (Diptera: Calliphoridae) of eastern Canada with a key to Calliphoridae subfamilies and genera of eastern North America, and a key to the eastern Canadian species of Calliphorinae, Luciliinae and Chrysomyiinae. Canadian Journal of Arthropod Identification. 11.
	<p>Tantawi, Whitworth, 2014. First record of Lucilia bufonivora Moniez, 1876 (Diptera: Calliphoridae) from North America and key to North American species of the L. bufonivora species group. Zootaxa. 3881(2): 101-124
	<p>Whitworth, 2006. Keys to the Genera and Species of Blow Flies (Diptera: Calliphoridae) of North America north of Mexico. Proceedings of the Entomological Society of Washington. 108(3): 689-725.
	<p>Whitworth, 2010. Keys to the genera and species of blow flies (Diptera: Calliphoridae) of the WestIndies and description of a new species of Lucilia Robineau-Desvoidy. Zootaxa.
	<p>Whitworth, 2014. A revision of the Neotropical species of Lucilia Robineau-Desvoidy (Diptera: Calliphoridae). Zootaxa.	<p>Williams, Villet, 2014. Morphological identification of Lucilia sericata, Lucilia cuprina and their hybrids (Diptera, Calliphoridae). ZooKeys 420. https://zookeys.pensoft.net/article/3908/

    </p>
</div>


</body>

</html>




